'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var pfBarChart = {

  /* ---
   * Chart configuration values
   */
  config: {
    barThickness: 40, // thickness of individual bars
    barGutter: 8, // space between bars
    labelWidth: 170, // label width
    labelHeight: 50, // label height
    labelBaseline: 20, // label text baseline
    labelColor: 'black', // text color for bar labels
    countColor: 'white', // text color for bar count text
    chartHeight: 500 // set height for vertical bar charts
  },

  /* ---
   * Function that creates a bar chart from the chartInfo object.
   */
  display: function display(chart, orientation) {
    this.chart = chart;
    this.orientation = orientation;

    this.getSvgDimensions();
    this.createSvg();

    switch (this.orientation) {
      case 'horizontal':
        pfHorizonal.create();
        break;
      case 'vertical':
        pfVertical.create();
        break;
    }
  },

  /* ---
   * Helper function that returns the base SVG object
   */
  createSvg: function createSvg() {
    this.svg = d3.select(this.chart.el).append('svg').attr('width', '100%').attr('height', this.height);

    if (this.chart.desc) {
      this.svg.append('desc').text(this.chart.desc);
    }
  },

  /* ---
   * Helper function for initial chart setup.
   */
  createBase: function createBase() {
    var _this = this;

    var base = this.svg.selectAll('g').data(this.chart.data.counts).enter().append('g');

    base.append('title').text(function (d, i) {
      return 'Data for ' + _this.chart.data.labels[i];
    });

    base.append('desc').text(function (d, i) {
      return 'The number of ' + _this.chart.data.labels[i] + ' is ' + d + ', which is ' + _this.getBarSize(d) + '% of the total.';
    });

    return base;
  },

  /* ---
   * Helper function to determine width and height of SVG based on chart orientation.
   */
  getSvgDimensions: function getSvgDimensions() {
    // SVG max size is the largest value in the dataset.
    //   Used for width in horizonal charts; bar height in vertical charts.
    this.maxSize = Math.max.apply(Math, _toConsumableArray(this.chart.data.counts));

    if (this.orientation == 'horizontal') {
      // Based on number of values in dataset for horizontal charts.
      this.height = this.chart.data.counts.length * (this.config.barThickness + this.config.barGutter);
    } else if (this.orientation == 'vertical') {
      // Fixed height for vertical charts.
      this.height = this.config.chartHeight;
    }
  },

  /* ---
   * Helper function that returns the size of the bar based on passed-in data.
   */
  getBarSize: function getBarSize(d) {
    if (!this.maxSize) {
      return 0;
    }
    return d / this.maxSize * 100;
  }
};

/* ******************************
 * Namespace for helper functions for HORIZONTAL bar charts only.
 */
var pfHorizonal = {

  /* ---
   * Displays the chart!
   */
  create: function create() {
    var _this2 = this;

    var chart = pfBarChart.createBase();

    // Draw the bars.
    chart.append('rect').attr('height', pfBarChart.config.barThickness).attr('width', function (d) {
      return pfBarChart.getBarSize(d) + '%';
    }).attr('x', pfBarChart.config.labelWidth).attr('y', function (d, i) {
      return _this2.barY(i);
    }).attr('fill', function (d, i) {
      return pfBarChart.chart.colors;
    });

    // Draw the chart labels.
    chart.append('text').text(function (d, i) {
      return pfBarChart.chart.data.labels[i];
    }).attr('height', pfBarChart.config.barThickness).attr('y', function (d, i) {
      return _this2.barY(i, pfBarChart.config.labelBaseline);
    }).attr('fill', pfBarChart.config.labelColor);

    // Draw the counter text on top of the bars.
    chart.append('text').text(function (d) {
      return d;
    }).attr('height', pfBarChart.config.barThickness).attr('x', pfBarChart.config.labelWidth + pfBarChart.config.barGutter).attr('y', function (d, i) {
      return _this2.barY(i, pfBarChart.config.labelBaseline);
    }).attr('fill', pfBarChart.config.countColor);

    return chart;
  },

  /* ---
   * Returns the y value (as px) of the bar, based on iterator.
   */
  barY: function barY(i) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -7;

    return i * pfBarChart.config.barThickness + i * pfBarChart.config.barGutter + offset;
  }

};

/* ******************************
 * Namespace for helper functions for VERTICAL bar charts only.
 */
var pfVertical = {

  /* ---
   * Displays the chart!
   */
  create: function create() {
    var _this3 = this;

    var chart = pfBarChart.createBase();

    var y = d3.scaleLinear().range([pfBarChart.config.chartHeight - pfBarChart.config.labelHeight, 0]);
    chart.attr('transform', 'translate(40,10)');
    chart.call(d3.axisLeft(y));

    // Draw the bars.
    chart.append('rect').attr('height', function (d) {
      return _this3.barHeight(d) + 'px';
    }).attr('width', function () {
      return _this3.barWidth() + '%';
    }).attr('x', function (d, i) {
      return _this3.barX(i) + '%';
    }).attr('y', function (d) {
      return _this3.barY(d);
    }).attr('fill', function (d, i) {
      return pfBarChart.chart.colors[i];
    });

    // Draw the chart labels.
    chart.append('text').text(function (d, i) {
      return pfBarChart.chart.data.labels[i];
    }).attr('height', pfBarChart.config.barThickness).attr('transform', 'translate(60,0)').attr('x', function (d, i) {
      return _this3.barX(i) + '%';
    }).attr('y', pfBarChart.config.chartHeight - pfBarChart.config.labelHeight / 2).attr('fill', pfBarChart.config.labelColor);

    return chart;
  },

  /* ---
   * Returns the height (as px) of the bar.
   */
  barHeight: function barHeight(d) {
    var size = pfBarChart.getBarSize(d);
    var chartHeight = pfBarChart.config.chartHeight - pfBarChart.config.labelHeight;
    return size / 100 * chartHeight;
  },

  /* ---
   * Returns the width (as %) of the bar.
   */
  barWidth: function barWidth() {
    var gutters = pfBarChart.chart.data.counts.length;
    return (100 - gutters) / pfBarChart.chart.data.counts.length;
  },

  /* ---
   * Returns the y value (as px) of the bar.
   */
  barY: function barY(d) {
    var height = this.barHeight(d);
    var chartHeight = pfBarChart.config.chartHeight - pfBarChart.config.labelHeight;
    return chartHeight - height;
  },

  /* ---
   * Returns the x value (as %) of the bar, based on iterator.
   */
  barX: function barX(i) {
    return i * (this.barWidth() + 1);
  }

};
'use strict';

var siChart = {

  /* ---
   * Function to create all charts for the page.
   *   - Charts are defined by the (not real) HTML <chart> tag.
   *   - Makes async AJAX calls for each chart.
   */
  create: function create(data, type) {
    var chart = {};
    chart.el = $('#' + type)[0];
    chart.data = this.processData(data, type);
    chart.colors = this.generateColors(type);

    pfBarChart.display(chart, 'horizontal');
  },

  /* ---
   * Function that saves out labels and chart data.
   */
  processData: function processData(data, type) {
    var labels = [],
        counts = [];

    for (var key in data.reports) {
      if (data.reports[key][type] !== undefined) {
        labels.push(key);
        counts.push(data.reports[key][type]);
      }
    }

    return { 'labels': labels, 'counts': counts };
  },

  /* ---
   * Function that generates an array of colors for the chart
   */
  generateColors: function generateColors(type) {
    if (type.includes('error')) {
      return '#AD0A0E';
    }

    if (type.includes('warning')) {
      return '#D3550A';
    }

    if (type.includes('review')) {
      return '#4E44C2';
    }
  }
};
'use strict';

// Click event for the "Get current data" button.
$('#getCurrentData').click(function () {
  $(this).attr('disabled', 'disabled').html('Fetching current issue data');

  $.ajax({
    url: 'actions/get_current_issues.php',
    success: function success(data) {
      $('#getCurrentData').removeClass('btn-primary').addClass('btn-secondary').html('Issue data is up-to-date!');
    }
  });
});

//
$('#selectSite').change(function () {
  var site = this.value;

  // Clear out any old charts
  $('#a_error, #a_warning, #a_review, #aa_error, #aa_warning, #aa_review, #aaa_error, #aaa_warning, #aaa_review').html('');

  // Make sure charts will display
  $('.charts, .pages').removeClass('hide');

  // Generate charts
  $.ajax({
    url: 'actions/get_site_issues.php',
    datatype: 'json',
    data: {
      site: site
    },
    success: function success(data) {
      var dataObj = JSON.parse(data);
      $('.pages span').html(dataObj.pages);

      siChart.create(dataObj, 'a_error');
      siChart.create(dataObj, 'a_warning');
      siChart.create(dataObj, 'a_review');

      siChart.create(dataObj, 'aa_error');
      siChart.create(dataObj, 'aa_warning');
      siChart.create(dataObj, 'aa_review');

      siChart.create(dataObj, 'aaa_error');
      siChart.create(dataObj, 'aaa_warning');
      siChart.create(dataObj, 'aaa_review');
    }
  });
});